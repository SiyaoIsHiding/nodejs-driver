## API Report File for "cassandra-driver"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as events from 'events';
import _Long = require('long');
import { Readable } from 'stream';
import * as stream from 'stream';
import * as tls from 'tls';
import { URL as URL_2 } from 'url';

// @public (undocumented)
export type ArrayOrObject = any[]|{[key: string]: any};

// @public (undocumented)
export namespace auth {
    // (undocumented)
    export interface Authenticator {
        // (undocumented)
        evaluateChallenge(challenge: Buffer, callback: Function): void;

        // (undocumented)
        initialResponse(callback: Function): void;

        // (undocumented)
        onAuthenticationSuccess(token?: Buffer): void;
    }

    // (undocumented)
    export interface AuthProvider {
        // (undocumented)
        newAuthenticator(endpoint: string, name: string): Authenticator;
    }

    // (undocumented)
    export class DseGssapiAuthProvider implements AuthProvider {
        constructor(gssOptions?: { authorizationId?: string, service?: string, hostNameResolver?: Function });

        // (undocumented)
        newAuthenticator(endpoint: string, name: string): Authenticator;
    }

    // (undocumented)
    export class DsePlainTextAuthProvider implements AuthProvider {
        constructor(username: string, password: string, authorizationId?: string);

        // (undocumented)
        newAuthenticator(endpoint: string, name: string): Authenticator;
    }

    // (undocumented)
    export class PlainTextAuthProvider implements AuthProvider {
        constructor(username: string, password: string);

        // (undocumented)
        newAuthenticator(endpoint: string, name: string): Authenticator;
    }
}

// @public (undocumented)
export class Client extends events.EventEmitter {
    constructor(options: DseClientOptions);
    // (undocumented)
    batch(
    queries: Array<string|{query: string, params?: ArrayOrObject}>,
    options?: QueryOptions): Promise<types.ResultSet>;
    // (undocumented)
    batch(
    queries: Array<string|{query: string, params?: ArrayOrObject}>,
    options: QueryOptions,
    callback: ValueCallback<types.ResultSet>): void;
    // (undocumented)
    batch(
    queries: Array<string|{query: string, params?: ArrayOrObject}>,
    callback: ValueCallback<types.ResultSet>): void;
    // (undocumented)
    connect(): Promise<void>;
    // (undocumented)
    connect(callback: EmptyCallback): void;
    // (undocumented)
    eachRow(query: string,
    params: ArrayOrObject,
    options: QueryOptions,
    rowCallback: (n: number, row: types.Row) => void,
    callback?: ValueCallback<types.ResultSet>): void;
    // (undocumented)
    eachRow(query: string,
    params: ArrayOrObject,
    rowCallback: (n: number, row: types.Row) => void,
    callback?: ValueCallback<types.ResultSet>): void;
    // (undocumented)
    eachRow(query: string,
    rowCallback: (n: number, row: types.Row) => void): void;
    // (undocumented)
    execute(query: string, params?: ArrayOrObject, options?: QueryOptions): Promise<types.ResultSet>;
    // (undocumented)
    execute(query: string, params: ArrayOrObject, options: QueryOptions, callback: ValueCallback<types.ResultSet>): void;
    // (undocumented)
    execute(query: string, params: ArrayOrObject, callback: ValueCallback<types.ResultSet>): void;
    // (undocumented)
    execute(query: string, callback: ValueCallback<types.ResultSet>): void;
    // Warning: (ae-forgotten-export) The symbol "graph" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    executeGraph(
    traversal: string,
    parameters: { [name: string]: any } | undefined,
    options: GraphQueryOptions,
    callback: ValueCallback<graph.GraphResultSet>): void;
    // (undocumented)
    executeGraph(
    traversal: string,
    parameters: { [name: string]: any } | undefined,
    callback: ValueCallback<graph.GraphResultSet>): void;
    // (undocumented)
    executeGraph(traversal: string, callback: ValueCallback<graph.GraphResultSet>): void;
    // (undocumented)
    executeGraph(
    traversal: string,
    parameters?: { [name: string]: any },
    options?: GraphQueryOptions): Promise<graph.GraphResultSet>;
    // (undocumented)
    getReplicas(keyspace: string, token: Buffer): Host[];
    // (undocumented)
    getState(): metadata.ClientState;
    // (undocumented)
    hosts: HostMap;
    // (undocumented)
    keyspace: string;
    // (undocumented)
    metadata: metadata.Metadata;
    // (undocumented)
    metrics: metrics.ClientMetrics;
    // (undocumented)
    shutdown(): Promise<void>;
    // (undocumented)
    shutdown(callback: EmptyCallback): void;
    // (undocumented)
    stream(query: string, params?: ArrayOrObject, options?: QueryOptions, callback?: EmptyCallback): events.EventEmitter;
}

// @public (undocumented)
export interface ClientOptions {
    // (undocumented)
    authProvider?: auth.AuthProvider;
    // (undocumented)
    cloud?: {
        secureConnectBundle: string | URL_2;
    };
    // (undocumented)
    contactPoints?: string[];
    // (undocumented)
    credentials?: {
        username: string;
        password: string;
    }
    // (undocumented)
    encoding?: {
        map?: Function;
        set?: Function;
        copyBuffer?: boolean;
        useUndefinedAsUnset?: boolean;
        useBigIntAsLong?: boolean;
        useBigIntAsVarint?: boolean;
    };
    // (undocumented)
    isMetadataSyncEnabled?: boolean;
    // (undocumented)
    keyspace?: string;
    // (undocumented)
    localDataCenter?: string;
    // (undocumented)
    maxPrepared?: number;
    // (undocumented)
    metrics?: metrics.ClientMetrics;
    // (undocumented)
    policies?: {
        addressResolution?: policies.addressResolution.AddressTranslator;
        loadBalancing?: policies.loadBalancing.LoadBalancingPolicy;
        reconnection?: policies.reconnection.ReconnectionPolicy;
        retry?: policies.retry.RetryPolicy;
        speculativeExecution?: policies.speculativeExecution.SpeculativeExecutionPolicy;
        timestampGeneration?: policies.timestampGeneration.TimestampGenerator;
    };
    // (undocumented)
    pooling?: {
        coreConnectionsPerHost?: { [key: number]: number; };
        heartBeatInterval?: number;
        maxRequestsPerConnection?: number;
        warmup?: boolean;
    };
    // (undocumented)
    prepareOnAllHosts?: boolean;
    // (undocumented)
    profiles?: ExecutionProfile[];
    // (undocumented)
    promiseFactory?: (handler: (callback: (err: Error, result?: any) => void) => void) => Promise<any>;
    // (undocumented)
    protocolOptions?: {
        maxSchemaAgreementWaitSeconds?: number;
        maxVersion?: number;
        noCompact?: boolean;
        port?: number;
    };
    // (undocumented)
    queryOptions?: QueryOptions;
    // (undocumented)
    refreshSchemaDelay?: number;
    // (undocumented)
    rePrepareOnUp?: boolean;
    // (undocumented)
    requestTracker?: tracker.RequestTracker;
    // (undocumented)
    socketOptions?: {
        coalescingThreshold?: number;
        connectTimeout?: number;
        defunctReadTimeoutThreshold?: number;
        keepAlive?: boolean;
        keepAliveDelay?: number;
        readTimeout?: number;
        tcpNoDelay?: boolean;
    };
    // (undocumented)
    sslOptions?: tls.ConnectionOptions;
}

// @public (undocumented)
export namespace concurrent {
    // (undocumented)
    export function executeConcurrent(
    client: Client,
    query: string,
    parameters: any[][]|Readable,
    options?: Options): Promise<ResultSetGroup>;

    // (undocumented)
    export function executeConcurrent(
    client: Client,
    queries: Array<{query: string, params: any[]}>,
    options?: Options): Promise<ResultSetGroup>;

    // (undocumented)
    export type Options = {
        collectResults?: boolean;
        concurrencyLevel?: number;
        executionProfile?: string;
        maxErrors?: number;
        raiseOnFirstError?: boolean;
    }

    // (undocumented)
    export interface ResultSetGroup {
        // (undocumented)
        errors: Error[];
        // (undocumented)
        resultItems: any[];
        // (undocumented)
        totalExecuted: number;
    }
}

// @public (undocumented)
export namespace datastax {
    import graph = graphModule.graph;

    import search = searchModule.search;
}

// @public (undocumented)
export function defaultOptions(): ClientOptions;

// @public (undocumented)
export interface DseClientOptions extends ClientOptions {
    // (undocumented)
    applicationName?: string;
    // (undocumented)
    applicationVersion?: string;
    // (undocumented)
    graphOptions?: GraphOptions;
    // (undocumented)
    id?: Uuid;
    // (undocumented)
    monitorReporting?: { enabled?: boolean };
}

// @public (undocumented)
export type EmptyCallback = (err: Error) => void;

// @public (undocumented)
export namespace errors {
    // (undocumented)
    export class ArgumentError extends DriverError {
        constructor(message: string);
    }

    // (undocumented)
    export class AuthenticationError extends DriverError {
        constructor(message: string);
    }

    // (undocumented)
    export class BusyConnectionError extends DriverError {
        constructor(address: string, maxRequestsPerConnection: number, connectionLength: number);
    }

    // (undocumented)
    export abstract class DriverError extends Error {
        constructor(message: string, constructor?: any);

        // (undocumented)
        info: string;
    }

    // (undocumented)
    export class DriverInternalError extends DriverError {
        constructor(message: string);
    }

    // (undocumented)
    export class NoHostAvailableError extends DriverError {
        constructor(innerErrors: any, message?: string);

        // (undocumented)
        innerErrors: any;
    }

    // (undocumented)
    export class NotSupportedError extends DriverError {
        constructor(message: string);
    }

    // (undocumented)
    export class OperationTimedOutError extends DriverError {
        constructor(message: string, host?: string);

        // (undocumented)
        host?: string;
    }

    // (undocumented)
    export class ResponseError extends DriverError {
        constructor(code: number, message: string);

        // (undocumented)
        code: number;
    }
}

// @public (undocumented)
export interface ExecutionOptions {
    // (undocumented)
    getCaptureStackTrace(): boolean;

    // (undocumented)
    getConsistency(): types.consistencies;

    // (undocumented)
    getCustomPayload(): { [key: string]: any };

    // (undocumented)
    getFetchSize(): number;

    // (undocumented)
    getFixedHost(): Host;

    // (undocumented)
    getHints(): string[] | string[][];

    // (undocumented)
    getKeyspace(): string;

    // (undocumented)
    getLoadBalancingPolicy(): policies.loadBalancing.LoadBalancingPolicy;

    // (undocumented)
    getPageState(): Buffer;

    // (undocumented)
    getRawQueryOptions(): QueryOptions;

    // (undocumented)
    getReadTimeout(): number;

    // (undocumented)
    getRetryPolicy(): policies.retry.RetryPolicy;

    // (undocumented)
    getRoutingKey(): Buffer | Buffer[];

    // (undocumented)
    getSerialConsistency(): types.consistencies;

    // (undocumented)
    getTimestamp(): number | Long | undefined | null;

    // (undocumented)
    isAutoPage(): boolean;

    // (undocumented)
    isBatchCounter(): boolean;

    // (undocumented)
    isBatchLogged(): boolean;

    // (undocumented)
    isIdempotent(): boolean;

    // (undocumented)
    isPrepared(): boolean;

    // (undocumented)
    isQueryTracing(): boolean;

    // (undocumented)
    setHints(hints: string[]): void;
}

// @public (undocumented)
export class ExecutionProfile {
    constructor(name: string, options: {
        consistency?: types.consistencies;
        loadBalancing?: policies.loadBalancing.LoadBalancingPolicy;
        readTimeout?: number;
        retry?: policies.retry.RetryPolicy;
        serialConsistency?: types.consistencies;
        graphOptions?: {
            name?: string;
            language?: string;
            source?: string;
            readConsistency?: types.consistencies;
            writeConsistency?: types.consistencies;
        };
    });
    // (undocumented)
    consistency?: types.consistencies;
    // (undocumented)
    graphOptions?: {
        name?: string;
        language?: string;
        source?: string;
        readConsistency?: types.consistencies;
        writeConsistency?: types.consistencies;
    };
    // (undocumented)
    loadBalancing?: policies.loadBalancing.LoadBalancingPolicy;
    // (undocumented)
    name: string;
    // (undocumented)
    readTimeout?: number;
    // (undocumented)
    retry?: policies.retry.RetryPolicy;
    // (undocumented)
    serialConsistency?: types.consistencies;
}

// @public (undocumented)
export namespace geometry {
    // (undocumented)
    export class LineString {
        constructor(...args: Point[]);

        // (undocumented)
        equals(other: LineString): boolean;

        // (undocumented)
        static fromBuffer(buffer: Buffer): LineString;

        // (undocumented)
        static fromString(textValue: string): LineString;

        // (undocumented)
        toBuffer(): Buffer;

        // (undocumented)
        toJSON(): string;

        // (undocumented)
        toString(): string;

    }

    // (undocumented)
    export class Point {
        constructor(x: number, y: number);

        // (undocumented)
        equals(other: Point): boolean;

        // (undocumented)
        static fromBuffer(buffer: Buffer): Point;

        // (undocumented)
        static fromString(textValue: string): Point;

        // (undocumented)
        toBuffer(): Buffer;

        // (undocumented)
        toJSON(): string;

        // (undocumented)
        toString(): string;

    }

    // (undocumented)
    export class Polygon {
        constructor(...args: Point[]);

        // (undocumented)
        equals(other: Polygon): boolean;

        // (undocumented)
        static fromBuffer(buffer: Buffer): Polygon;

        // (undocumented)
        static fromString(textValue: string): Polygon;

        // (undocumented)
        toBuffer(): Buffer;

        // (undocumented)
        toJSON(): string;

        // (undocumented)
        toString(): string;
    }
}

// @public (undocumented)
export type GraphOptions = {
    language?: string;
    name?: string;
    readConsistency?: types.consistencies;
    readTimeout?: number;
    source?: string;
    writeConsistency?: types.consistencies;
};

// @public (undocumented)
export interface GraphQueryOptions extends QueryOptions {
    // (undocumented)
    graphLanguage?: string;
    // (undocumented)
    graphName?: string;
    // (undocumented)
    graphReadConsistency?: types.consistencies;
    // (undocumented)
    graphSource?: string;
    // (undocumented)
    graphWriteConsistency?: types.consistencies;
}

// @public (undocumented)
export interface Host extends events.EventEmitter {
    // (undocumented)
    address: string;
    // (undocumented)
    canBeConsideredAsUp(): boolean;
    // (undocumented)
    cassandraVersion: string;
    // (undocumented)
    datacenter: string;
    // (undocumented)
    getCassandraVersion(): number[];
    // (undocumented)
    hostId: types.Uuid;
    // (undocumented)
    isUp(): boolean;
    // (undocumented)
    rack: string;
    // (undocumented)
    tokens: string[];
}

// @public (undocumented)
export interface HostMap extends events.EventEmitter {
    // (undocumented)
    forEach(callback: (value: Host, key: string) => void): void;

    // (undocumented)
    get(key: string): Host;

    // (undocumented)
    keys(): string[];

    // (undocumented)
    length: number;

    // (undocumented)
    values(): Host[];
}

// @public (undocumented)
export namespace mapping {
    // (undocumented)
    export class DefaultTableMappings implements TableMappings {
        // (undocumented)
        getColumnName(propName: string): string;

        // (undocumented)
        getPropertyName(columnName: string): string;

        // (undocumented)
        newObjectInstance(): any;
    }

    // (undocumented)
    export type FindDocInfo = {
        fields?: string[];
        orderBy?: { [key: string]: string };
        limit?: number;
    }

    // (undocumented)
    export type InsertDocInfo = {
        fields?: string[];
        ttl?: number;
        ifNotExists?: boolean;
    }

    // (undocumented)
    export class Mapper {
        constructor(client: Client, options?: MappingOptions);

        // (undocumented)
        batch(items: ModelBatchItem[], executionOptions?: string | MappingExecutionOptions): Promise<Result>;

        // (undocumented)
        forModel<T = any>(name: string): ModelMapper<T>;
    }

    // (undocumented)
    export type MappingExecutionOptions = {
        executionProfile?: string;
        isIdempotent?: boolean;
        logged?: boolean;
        timestamp?: number | Long;
        fetchSize?: number;
        pageState?: number;
    }

    // (undocumented)
    export type MappingOptions = {
        models: { [key: string]: ModelOptions };
    }

    // (undocumented)
    export interface ModelBatchItem {

    }

    // (undocumented)
    export interface ModelBatchMapper {
        // (undocumented)
        insert(doc: any, docInfo?: InsertDocInfo): ModelBatchItem;

        // (undocumented)
        remove(doc: any, docInfo?: RemoveDocInfo): ModelBatchItem;

        // (undocumented)
        update(doc: any, docInfo?: UpdateDocInfo): ModelBatchItem;
    }

    // (undocumented)
    export type ModelColumnOptions = {
        name: string;
        toModel?: (columnValue: any) => any;
        fromModel?: (modelValue: any) => any;
    };

    // (undocumented)
    export interface ModelMapper<T = any> {
        // (undocumented)
        batching: ModelBatchMapper;
        // (undocumented)
        find(doc: { [key: string]: any }, docInfo?: FindDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
        // (undocumented)
        findAll(docInfo?: FindDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
        // (undocumented)
        get(doc: { [key: string]: any }, docInfo?: { fields?: string[] }, executionOptions?: string | MappingExecutionOptions): Promise<null | T>;
        // (undocumented)
        insert(doc: { [key: string]: any }, docInfo?: InsertDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
        // (undocumented)
        mapWithQuery(
        query: string,
        paramsHandler: (doc: any) => any[],
        executionOptions?: string | MappingExecutionOptions
        ): (doc: any, executionOptions?: string | MappingExecutionOptions) => Promise<Result<T>>;
        // (undocumented)
        name: string;
        // (undocumented)
        remove(doc: { [key: string]: any }, docInfo?: RemoveDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
        // (undocumented)
        update(doc: { [key: string]: any }, docInfo?: UpdateDocInfo, executionOptions?: string | MappingExecutionOptions): Promise<Result<T>>;
    }

    // (undocumented)
    export type ModelOptions = {
        tables?: string[] | ModelTables[];
        mappings?: TableMappings;
        columns?: { [key: string]: string|ModelColumnOptions };
        keyspace?: string;
    }

    // (undocumented)
    export interface ModelTables {
        // (undocumented)
        isView: boolean;
        // (undocumented)
        name: string;
    }

    // (undocumented)
    export namespace q {
        // (undocumented)
        export function and(condition1: any, condition2: any): QueryOperator;

        // (undocumented)
        export function append(value: any): QueryOperator;

        // (undocumented)
        export function decr(value: any): QueryOperator;

        // (undocumented)
        export function gt(value: any): QueryOperator;

        // (undocumented)
        export function gte(value: any): QueryOperator;

        // (undocumented)
        export function in_(arr: any): QueryOperator;

        // (undocumented)
        export function incr(value: any): QueryOperator;

        // (undocumented)
        export function lt(value: any): QueryOperator;

        // (undocumented)
        export function lte(value: any): QueryOperator;

        // (undocumented)
        export function notEq(value: any): QueryOperator;

        // (undocumented)
        export function prepend(value: any): QueryOperator;

        // (undocumented)
        export interface QueryOperator {

        }

        // (undocumented)
        export function remove(value: any): QueryOperator;
    }

    // (undocumented)
    export type RemoveDocInfo = {
        fields?: string[];
        ttl?: number;
        ifExists?: boolean;
        when?: { [key: string]: any };
        deleteOnlyColumns?: boolean;
    }

    // (undocumented)
    export interface Result<T = any> extends Iterator<T> {
        // (undocumented)
        first(): T | null;

        // (undocumented)
        forEach(callback: (currentValue: T, index: number) => void, thisArg?: any): void;

        // (undocumented)
        toArray(): T[];

        // (undocumented)
        wasApplied(): boolean;
    }

    // (undocumented)
    export interface TableMappings {
        // (undocumented)
        getColumnName(propName: string): string;

        // (undocumented)
        getPropertyName(columnName: string): string;

        // (undocumented)
        newObjectInstance(): any;
    }

    // (undocumented)
    export class UnderscoreCqlToCamelCaseMappings implements TableMappings {
        // (undocumented)
        getColumnName(propName: string): string;

        // (undocumented)
        getPropertyName(columnName: string): string;

        // (undocumented)
        newObjectInstance(): any;
    }

    // (undocumented)
    export type UpdateDocInfo = {
        fields?: string[];
        ttl?: number;
        ifExists?: boolean;
        when?: { [key: string]: any };
        orderBy?: { [key: string]: string };
        limit?: number;
        deleteOnlyColumns?: boolean;
    }
}

// @public (undocumented)
export namespace metadata {

    // (undocumented)
    export interface Aggregate {
        // (undocumented)
        argumentTypes: Array<{ code: dataTypes, info: any }>;
        // (undocumented)
        finalFunction: string;
        // (undocumented)
        initCondition: string;
        // (undocumented)
        keyspaceName: string;
        // (undocumented)
        returnType: string;
        // (undocumented)
        signature: string[];
        // (undocumented)
        stateFunction: string;
        // (undocumented)
        stateType: string;
    }

    // (undocumented)
    export interface ClientState {
        // (undocumented)
        getConnectedHosts(): Host[];

        // (undocumented)
        getInFlightQueries(host: Host): number;

        // (undocumented)
        getOpenConnections(host: Host): number;

        // (undocumented)
        toString(): string;
    }

    // (undocumented)
    export interface ColumnInfo {
        // (undocumented)
        name: string;
        // (undocumented)
        type: DataTypeInfo;
    }

    // (undocumented)
    export interface DataCollection {
        // (undocumented)
        bloomFilterFalsePositiveChance: number;
        // (undocumented)
        caching: string;
        // (undocumented)
        clusteringKeys: ColumnInfo[];
        // (undocumented)
        clusteringOrder: string[];
        // (undocumented)
        columns: ColumnInfo[];
        // (undocumented)
        columnsByName: { [key: string]: ColumnInfo };
        // (undocumented)
        comment: string;
        // (undocumented)
        compactionClass: string;
        // (undocumented)
        compactionOptions: { [option: string]: any; };
        // (undocumented)
        compression: {
            class?: string;
            [option: string]: any;
        };
        // (undocumented)
        crcCheckChange?: number;
        // (undocumented)
        defaultTtl: number;
        // (undocumented)
        extensions: { [option: string]: any; };
        // (undocumented)
        gcGraceSeconds: number;
        // (undocumented)
        localReadRepairChance: number;
        // (undocumented)
        maxIndexInterval?: number;
        // (undocumented)
        minIndexInterval?: number;
        // (undocumented)
        name: string;
        // (undocumented)
        partitionKeys: ColumnInfo[];
        // (undocumented)
        populateCacheOnFlush: boolean;
        // (undocumented)
        readRepairChance: number;
        // (undocumented)
        speculativeRetry: string;
    }

    // (undocumented)
    export interface DataTypeInfo {
        // (undocumented)
        code: dataTypes;
        // (undocumented)
        info: string | DataTypeInfo | DataTypeInfo[];
        // (undocumented)
        options: {
            frozen: boolean;
            reversed: boolean;
        };
    }

    // (undocumented)
    export interface Index {
        // (undocumented)
        isCompositesKind(): boolean;
        // (undocumented)
        isCustomKind(): boolean;
        // (undocumented)
        isKeysKind(): boolean;
        // (undocumented)
        kind: IndexKind;
        // (undocumented)
        name: string;
        // (undocumented)
        options: object;
        // (undocumented)
        target: string;
    }

    // (undocumented)
    export enum IndexKind {
        // (undocumented)
        composites,
        // (undocumented)
        custom = 0,
        // (undocumented)
        keys
    }

    // (undocumented)
    export interface MaterializedView extends DataCollection {
        // (undocumented)
        includeAllColumns: boolean;
        // (undocumented)
        tableName: string;
        // (undocumented)
        whereClause: string;
    }

    // (undocumented)
    export interface Metadata {
        // (undocumented)
        clearPrepared(): void;

        // (undocumented)
        getAggregate(keyspaceName: string, name: string, signature: string[] | Array<{ code: number, info: any }>, callback: ValueCallback<Aggregate>): void;

        // (undocumented)
        getAggregate(keyspaceName: string, name: string, signature: string[] | Array<{ code: number, info: any }>): Promise<Aggregate>;

        // (undocumented)
        getAggregates(keyspaceName: string, name: string, callback: ValueCallback<Aggregate[]>): void;

        // (undocumented)
        getAggregates(keyspaceName: string, name: string): Promise<Aggregate[]>;

        // (undocumented)
        getFunction(keyspaceName: string, name: string, signature: string[] | Array<{ code: number, info: any }>, callback: ValueCallback<SchemaFunction>): void;

        // (undocumented)
        getFunction(keyspaceName: string, name: string, signature: string[] | Array<{ code: number, info: any }>): Promise<SchemaFunction>;

        // (undocumented)
        getFunctions(keyspaceName: string, name: string, callback: ValueCallback<SchemaFunction[]>): void;

        // (undocumented)
        getFunctions(keyspaceName: string, name: string): Promise<SchemaFunction[]>;

        // (undocumented)
        getMaterializedView(keyspaceName: string, name: string, callback: ValueCallback<MaterializedView>): void;

        // (undocumented)
        getMaterializedView(keyspaceName: string, name: string, callback: EmptyCallback): Promise<MaterializedView>;

        // (undocumented)
        getReplicas(keyspaceName: string, token: Buffer | token.Token | token.TokenRange): Host[];

        // (undocumented)
        getTable(keyspaceName: string, name: string, callback: ValueCallback<TableMetadata>): void;

        // (undocumented)
        getTable(keyspaceName: string, name: string): Promise<TableMetadata>;

        // (undocumented)
        getTokenRanges(): Set<token.TokenRange>;

        // (undocumented)
        getTokenRangesForHost(keyspaceName: string, host: Host): Set<token.TokenRange> | null;

        // (undocumented)
        getTrace(traceId: Uuid, consistency: types.consistencies, callback: ValueCallback<QueryTrace>): void;

        // (undocumented)
        getTrace(traceId: Uuid, consistency: types.consistencies): Promise<QueryTrace>;

        // (undocumented)
        getTrace(traceId: Uuid, callback: ValueCallback<QueryTrace>): void;

        // (undocumented)
        getTrace(traceId: Uuid): Promise<QueryTrace>;

        // (undocumented)
        getUdt(keyspaceName: string, name: string, callback: ValueCallback<Udt>): void;

        // (undocumented)
        getUdt(keyspaceName: string, name: string): Promise<Udt>;

        // (undocumented)
        keyspaces: { [name: string]: { name: string, strategy: string }};

        // (undocumented)
        newToken(components: Buffer[] | Buffer | string): token.Token;

        // (undocumented)
        newTokenRange(start: token.Token, end: token.Token): token.TokenRange;

        // (undocumented)
        refreshKeyspace(name: string, callback: EmptyCallback): void;

        // (undocumented)
        refreshKeyspace(name: string): Promise<void>;

        // (undocumented)
        refreshKeyspaces(waitReconnect: boolean, callback: EmptyCallback): void;

        // (undocumented)
        refreshKeyspaces(waitReconnect?: boolean): Promise<void>;

        // (undocumented)
        refreshKeyspaces(callback: EmptyCallback): void;
    }

    // (undocumented)
    export interface QueryTrace {
        // (undocumented)
        clientAddress: string;
        // (undocumented)
        coordinator: InetAddress;
        // (undocumented)
        duration: number;
        // (undocumented)
        events: Array<{ id: Uuid; activity: any; source: any; elapsed: any; thread: any }>;
        // (undocumented)
        parameters: { [key: string]: any };
        // (undocumented)
        requestType: string;
        // (undocumented)
        startedAt: number | types.Long;
    }

    // (undocumented)
    export interface SchemaFunction {
        // (undocumented)
        argumentNames: string[];
        // (undocumented)
        argumentTypes: Array<{ code: dataTypes, info: any }>;
        // (undocumented)
        body: string;
        // (undocumented)
        calledOnNullInput: boolean;
        // (undocumented)
        keyspaceName: string;
        // (undocumented)
        language: string;
        // (undocumented)
        name: string;
        // (undocumented)
        returnType: string;
        // (undocumented)
        signature: string[];
    }

    // (undocumented)
    export interface TableMetadata extends DataCollection {
        // (undocumented)
        cdc?: boolean;
        // (undocumented)
        indexes: Index[];
        // (undocumented)
        indexInterval?: number;
        // (undocumented)
        isCompact: boolean;
        // (undocumented)
        memtableFlushPeriod: number;
        // (undocumented)
        replicateOnWrite: boolean;
        // (undocumented)
        virtual: boolean;
    }

    // (undocumented)
    export interface Udt {
        // (undocumented)
        fields: ColumnInfo[]
        // (undocumented)
        name: string;
    }
}

// @public (undocumented)
export namespace metrics {
    // (undocumented)
    export interface ClientMetrics {
        // (undocumented)
        onAuthenticationError(e: Error | errors.AuthenticationError): void;

        // (undocumented)
        onClientTimeoutError(e: errors.OperationTimedOutError): void;

        // (undocumented)
        onClientTimeoutRetry(e: Error): void;

        // (undocumented)
        onConnectionError(e: Error): void;

        // (undocumented)
        onIgnoreError(e: Error): void;

        // (undocumented)
        onOtherError(e: Error): void;

        // (undocumented)
        onOtherErrorRetry(e: Error): void;

        // (undocumented)
        onReadTimeoutError(e: errors.ResponseError): void;

        // (undocumented)
        onReadTimeoutRetry(e: Error): void;

        // (undocumented)
        onResponse(latency: number[]): void;

        // (undocumented)
        onSpeculativeExecution(): void;

        // (undocumented)
        onSuccessfulResponse(latency: number[]): void;

        // (undocumented)
        onUnavailableError(e: errors.ResponseError): void;

        // (undocumented)
        onUnavailableRetry(e: Error): void;

        // (undocumented)
        onWriteTimeoutError(e: errors.ResponseError): void;

        // (undocumented)
        onWriteTimeoutRetry(e: Error): void;
    }

    // (undocumented)
    export class DefaultMetrics implements ClientMetrics {
        constructor();

        // (undocumented)
        onAuthenticationError(e: Error | errors.AuthenticationError): void;

        // (undocumented)
        onClientTimeoutError(e: errors.OperationTimedOutError): void;

        // (undocumented)
        onClientTimeoutRetry(e: Error): void;

        // (undocumented)
        onConnectionError(e: Error): void;

        // (undocumented)
        onIgnoreError(e: Error): void;

        // (undocumented)
        onOtherError(e: Error): void;

        // (undocumented)
        onOtherErrorRetry(e: Error): void;

        // (undocumented)
        onReadTimeoutError(e: errors.ResponseError): void;

        // (undocumented)
        onReadTimeoutRetry(e: Error): void;

        // (undocumented)
        onResponse(latency: number[]): void;

        // (undocumented)
        onSpeculativeExecution(): void;

        // (undocumented)
        onSuccessfulResponse(latency: number[]): void;

        // (undocumented)
        onUnavailableError(e: errors.ResponseError): void;

        // (undocumented)
        onUnavailableRetry(e: Error): void;

        // (undocumented)
        onWriteTimeoutError(e: errors.ResponseError): void;

        // (undocumented)
        onWriteTimeoutRetry(e: Error): void;
    }
}

// @public (undocumented)
export namespace policies {
    // (undocumented)
    export namespace addressResolution {
        // (undocumented)
        export interface AddressTranslator {
            // (undocumented)
            translate(address: string, port: number, callback: Function): void;
        }

        // (undocumented)
        export class EC2MultiRegionTranslator implements AddressTranslator {
            // (undocumented)
            translate(address: string, port: number, callback: Function): void;
        }
    }

    // (undocumented)
    export function defaultAddressTranslator(): addressResolution.AddressTranslator;

    // (undocumented)
    export function defaultLoadBalancingPolicy(localDc?: string): loadBalancing.LoadBalancingPolicy;

    // (undocumented)
    export function defaultReconnectionPolicy(): reconnection.ReconnectionPolicy;

    // (undocumented)
    export function defaultRetryPolicy(): retry.RetryPolicy;

    // (undocumented)
    export function defaultSpeculativeExecutionPolicy(): speculativeExecution.SpeculativeExecutionPolicy;

    // (undocumented)
    export function defaultTimestampGenerator(): timestampGeneration.TimestampGenerator;

    // (undocumented)
    export namespace loadBalancing {
        // (undocumented)
        export class AllowListPolicy extends LoadBalancingPolicy {
            constructor(childPolicy: LoadBalancingPolicy, allowList: string[]);
        }

        // (undocumented)
        export class DCAwareRoundRobinPolicy extends LoadBalancingPolicy {
            constructor(localDc: string);
        }

        // (undocumented)
        export class DefaultLoadBalancingPolicy extends LoadBalancingPolicy {
            constructor(options?: { localDc?: string, filter?: (host: Host) => boolean });
        }

        // (undocumented)
        export abstract class LoadBalancingPolicy {
            // (undocumented)
            getDistance(host: Host): types.distance;

            // (undocumented)
            getOptions(): Map<string, object>;

            // (undocumented)
            init(client: Client, hosts: HostMap, callback: EmptyCallback): void;

            // (undocumented)
            newQueryPlan(
            keyspace: string,
            executionOptions: ExecutionOptions,
            callback: (error: Error, iterator: Iterator<Host>) => void): void;
        }

        // (undocumented)
        export class RoundRobinPolicy extends LoadBalancingPolicy {
            constructor();
        }

        // (undocumented)
        export class TokenAwarePolicy extends LoadBalancingPolicy {
            constructor(childPolicy: LoadBalancingPolicy);
        }

        // (undocumented)
        export class WhiteListPolicy extends AllowListPolicy {
        }
    }

    // (undocumented)
    export namespace reconnection {
        // (undocumented)
        export class ConstantReconnectionPolicy implements ReconnectionPolicy {
            constructor(delay: number);

            // (undocumented)
            getOptions(): Map<string, object>;

            // (undocumented)
            newSchedule(): Iterator<number>;

        }

        // (undocumented)
        export class ExponentialReconnectionPolicy implements ReconnectionPolicy {
            constructor(baseDelay: number, maxDelay: number, startWithNoDelay?: boolean);

            // (undocumented)
            getOptions(): Map<string, object>;

            // (undocumented)
            newSchedule(): Iterator<number>;
        }

        // (undocumented)
        export interface ReconnectionPolicy {
            // (undocumented)
            getOptions(): Map<string, object>;

            // (undocumented)
            newSchedule(): Iterator<number>;
        }
    }

    // (undocumented)
    export namespace retry {
        // (undocumented)
        export class DecisionInfo {
            // (undocumented)
            consistency: types.consistencies;
            // (undocumented)
            decision: number;
        }

        // (undocumented)
        export class FallthroughRetryPolicy extends RetryPolicy {
            constructor();
        }

        // (undocumented)
        export class IdempotenceAwareRetryPolicy extends RetryPolicy {
            constructor(childPolicy: RetryPolicy);
        }

        // (undocumented)
        export class OperationInfo {
            // (undocumented)
            executionOptions: ExecutionOptions;
            // (undocumented)
            nbRetry: number;
            // (undocumented)
            query: string;
        }

        // (undocumented)
        export namespace RetryDecision {
            // (undocumented)
            export enum retryDecision {
                // (undocumented)
                ignore,
                // (undocumented)
                rethrow,
                // (undocumented)
                retry
            }
        }

        // (undocumented)
        export class RetryPolicy {
            // (undocumented)
            onReadTimeout(
            info: OperationInfo,
            consistency: types.consistencies,
            received: number,
            blockFor: number,
            isDataPresent: boolean): DecisionInfo;

            // (undocumented)
            onRequestError(info: OperationInfo, consistency: types.consistencies, err: Error): DecisionInfo;

            // (undocumented)
            onUnavailable(
            info: OperationInfo, consistency: types.consistencies, required: number, alive: boolean): DecisionInfo;

            // (undocumented)
            onWriteTimeout(
            info: OperationInfo,
            consistency: types.consistencies,
            received: number,
            blockFor: number,
            writeType: string): DecisionInfo;

            // (undocumented)
            rethrowResult(): DecisionInfo;

            // (undocumented)
            retryResult(consistency: types.consistencies, useCurrentHost?: boolean): DecisionInfo;
        }
    }

    // (undocumented)
    export namespace speculativeExecution {
        // (undocumented)
        export class ConstantSpeculativeExecutionPolicy implements SpeculativeExecutionPolicy {
            constructor(delay: number, maxSpeculativeExecutions: number);

            // (undocumented)
            getOptions(): Map<string, object>;

            // (undocumented)
            init(client: Client): void;

            // (undocumented)
            newPlan(keyspace: string, queryInfo: string | Array<object>): { nextExecution: Function };

            // (undocumented)
            shutdown(): void;
        }

        // (undocumented)
        export class NoSpeculativeExecutionPolicy implements SpeculativeExecutionPolicy {
            constructor();

            // (undocumented)
            getOptions(): Map<string, object>;

            // (undocumented)
            init(client: Client): void;

            // (undocumented)
            newPlan(keyspace: string, queryInfo: string | Array<object>): { nextExecution: Function };

            // (undocumented)
            shutdown(): void;
        }

        // (undocumented)
        export interface SpeculativeExecutionPolicy {
            // (undocumented)
            getOptions(): Map<string, object>;

            // (undocumented)
            init(client: Client): void;

            // (undocumented)
            newPlan(keyspace: string, queryInfo: string|Array<object>): { nextExecution: Function };

            // (undocumented)
            shutdown(): void;
        }
    }

    // (undocumented)
    export namespace timestampGeneration {
        // (undocumented)
        export class MonotonicTimestampGenerator implements TimestampGenerator {
            constructor(warningThreshold: number, minLogInterval: number);

            // (undocumented)
            getDate(): number;

            // (undocumented)
            next(client: Client): types.Long | number;
        }

        // (undocumented)
        export interface TimestampGenerator {
            // (undocumented)
            next(client: Client): types.Long|number;
        }
    }
}

// @public (undocumented)
export interface QueryOptions {
    // (undocumented)
    autoPage?: boolean;
    // (undocumented)
    captureStackTrace?: boolean;
    // (undocumented)
    consistency?: number;
    // (undocumented)
    counter?: boolean;
    // (undocumented)
    customPayload?: any;
    // (undocumented)
    executionProfile?: string | ExecutionProfile;
    // (undocumented)
    fetchSize?: number;
    // (undocumented)
    hints?: string[] | string[][];
    // (undocumented)
    host?: Host;
    // (undocumented)
    isIdempotent?: boolean;
    // (undocumented)
    keyspace?: string;
    // (undocumented)
    logged?: boolean;
    // (undocumented)
    pageState?: Buffer | string;
    // (undocumented)
    prepare?: boolean;
    // (undocumented)
    readTimeout?: number;
    // (undocumented)
    retry?: policies.retry.RetryPolicy;
    // (undocumented)
    routingIndexes?: number[];
    // (undocumented)
    routingKey?: Buffer | Buffer[];
    // (undocumented)
    routingNames?: string[];
    // (undocumented)
    serialConsistency?: number;
    // (undocumented)
    timestamp?: number | Long;
    // (undocumented)
    traceQuery?: boolean;
}

// @public (undocumented)
export namespace token {
    // (undocumented)
    export interface Token {
        // (undocumented)
        compare(other: Token): number;

        // (undocumented)
        equals(other: Token): boolean;

        // (undocumented)
        getType(): { code: types.dataTypes, info: any };

        // (undocumented)
        getValue(): any;
    }

    // (undocumented)
    export interface TokenRange {
        // (undocumented)
        compare(other: TokenRange): number;
        // (undocumented)
        contains(token: Token): boolean;
        // (undocumented)
        end: Token;
        // (undocumented)
        equals(other: TokenRange): boolean;
        // (undocumented)
        isEmpty(): boolean;
        // (undocumented)
        isWrappedAround(): boolean;
        // (undocumented)
        splitEvenly(numberOfSplits: number): TokenRange[];
        // (undocumented)
        start: Token;
        // (undocumented)
        unwrap(): TokenRange[];
    }
}

// @public (undocumented)
export namespace tracker {
    // (undocumented)
    export class RequestLogger implements RequestTracker {
        constructor(options: {
            slowThreshold?: number;
            logNormalRequests?: boolean;
            logErroredRequests?: boolean;
            messageMaxQueryLength?: number;
            messageMaxParameterValueLength?: number;
            messageMaxErrorStackTraceLength?: number;
        });

        // (undocumented)
        onError(host: Host, query: string | Array<{ query: string; params?: any }>, parameters: any[] | { [p: string]: any } | null, executionOptions: ExecutionOptions, requestLength: number, err: Error, latency: number[]): void;

        // (undocumented)
        onSuccess(host: Host, query: string | Array<{ query: string; params?: any }>, parameters: any[] | { [p: string]: any } | null, executionOptions: ExecutionOptions, requestLength: number, responseLength: number, latency: number[]): void;

        // (undocumented)
        shutdown(): void;
    }

    // (undocumented)
    export interface RequestTracker {
        // (undocumented)
        onError(
        host: Host,
        query: string | Array<{ query: string, params?: any }>,
        parameters: any[] | { [key: string]: any } | null,
        executionOptions: ExecutionOptions,
        requestLength: number,
        err: Error,
        latency: number[]): void;

        // (undocumented)
        onSuccess(
        host: Host,
        query: string | Array<{ query: string, params?: any }>,
        parameters: any[] | { [key: string]: any } | null,
        executionOptions: ExecutionOptions,
        requestLength: number,
        responseLength: number,
        latency: number[]): void;

        // (undocumented)
        shutdown(): void;
    }
}

// @public (undocumented)
export namespace types {
    // (undocumented)
    export class BigDecimal {
        constructor(unscaledValue: number, scale: number);

        // (undocumented)
        add(other: BigDecimal): BigDecimal;

        // (undocumented)
        compare(other: BigDecimal): number;

        // (undocumented)
        equals(other: BigDecimal): boolean;

        // (undocumented)
        static fromBuffer(buf: Buffer): BigDecimal;

        // (undocumented)
        static fromNumber(value: number): BigDecimal;

        // (undocumented)
        static fromString(value: string): BigDecimal;

        // (undocumented)
        greaterThan(other: BigDecimal): boolean;

        // (undocumented)
        isNegative(): boolean;

        // (undocumented)
        isZero(): boolean;

        // (undocumented)
        notEquals(other: BigDecimal): boolean;

        // (undocumented)
        subtract(other: BigDecimal): BigDecimal;

        // (undocumented)
        static toBuffer(value: BigDecimal): Buffer;

        // (undocumented)
        toJSON(): string;

        // (undocumented)
        toNumber(): number;

        // (undocumented)
        toString(): string;
    }

    // (undocumented)
    export enum consistencies {
        // (undocumented)
        all = 0x05,
        // (undocumented)
        any = 0x00,
        // (undocumented)
        eachQuorum = 0x07,
        // (undocumented)
        localOne = 0x0a,
        // (undocumented)
        localQuorum = 0x06,
        // (undocumented)
        localSerial = 0x09,
        // (undocumented)
        one = 0x01,
        // (undocumented)
        quorum = 0x04,
        // (undocumented)
        serial = 0x08,
        // (undocumented)
        three = 0x03,
        // (undocumented)
        two = 0x02
    }

    // (undocumented)
    export enum dataTypes {
        // (undocumented)
        ascii = 0x0001,
        // (undocumented)
        bigint = 0x0002,
        // (undocumented)
        blob = 0x0003,
        // (undocumented)
        boolean = 0x0004,
        // (undocumented)
        counter = 0x0005,
        // (undocumented)
        custom = 0x0000,
        // (undocumented)
        date = 0x0011,
        // (undocumented)
        decimal = 0x0006,
        // (undocumented)
        double = 0x0007,
        // (undocumented)
        duration = 0x0015,
        // (undocumented)
        float = 0x0008,
        // (undocumented)
        inet = 0x0010,
        // (undocumented)
        int = 0x0009,
        // (undocumented)
        list = 0x0020,
        // (undocumented)
        map = 0x0021,
        // (undocumented)
        set = 0x0022,
        // (undocumented)
        smallint = 0x0013,
        // (undocumented)
        text = 0x000a,
        // (undocumented)
        time = 0x0012,
        // (undocumented)
        timestamp = 0x000b,
        // (undocumented)
        timeuuid = 0x000f,
        // (undocumented)
        tinyint = 0x0014,
        // (undocumented)
        tuple = 0x0031,
        // (undocumented)
        udt = 0x0030,
        // (undocumented)
        uuid = 0x000c,
        // (undocumented)
        varchar = 0x000d,
        // (undocumented)
        varint = 0x000e,
    }

    // (undocumented)
    export enum distance {
        // (undocumented)
        ignored,
        // (undocumented)
        local = 0,
        // (undocumented)
        remote
    }

    // (undocumented)
    export class Duration {
        constructor(month: number, days: number, nanoseconds: number | Long);

        // (undocumented)
        equals(other: Duration): boolean;

        // (undocumented)
        static fromBuffer(buffer: Buffer): Duration;

        // (undocumented)
        static fromString(input: string): Duration;

        // (undocumented)
        toBuffer(): Buffer;

        // (undocumented)
        toString(): string;
    }

    // (undocumented)
    export class InetAddress {
        constructor(buffer: Buffer);

        // (undocumented)
        equals(other: InetAddress): boolean;

        // (undocumented)
        static fromString(value: string): InetAddress;

        // (undocumented)
        getBuffer(): Buffer;

        // (undocumented)
        length: number;

        // (undocumented)
        toJSON(): string;

        // (undocumented)
        toString(): string;

        // (undocumented)
        version: number;
    }

    // (undocumented)
    export class Integer {
        constructor(bits: Array<number>, sign: number);
        // (undocumented)
        abs(): Integer;
        // (undocumented)
        add(other: Integer): Integer;
        // (undocumented)
        compare(other: Integer): number;
        // (undocumented)
        divide(other: Integer): Integer;
        // (undocumented)
        equals(other: Integer): boolean;
        // (undocumented)
        static fromBits(bits: Array<number>): Integer;
        // (undocumented)
        static fromBuffer(bits: Buffer): Integer;
        // (undocumented)
        static fromInt(value: number): Integer;
        // (undocumented)
        static fromNumber(value: number): Integer;
        // (undocumented)
        static fromString(str: string, opt_radix?: number): Integer;
        // (undocumented)
        getBits(index: number): number;
        // (undocumented)
        getBitsUnsigned(index: number): number;
        // (undocumented)
        getSign(): number;
        // (undocumented)
        greaterThan(other: Integer): boolean;
        // (undocumented)
        greaterThanOrEqual(other: Integer): boolean;
        // (undocumented)
        isNegative(): boolean;
        // (undocumented)
        isOdd(): boolean;
        // (undocumented)
        isZero(): boolean;
        // (undocumented)
        lessThan(other: Integer): boolean;
        // (undocumented)
        lessThanOrEqual(other: Integer): boolean;
        // (undocumented)
        modulo(other: Integer): Integer;
        // (undocumented)
        multiply(other: Integer): Integer;
        // (undocumented)
        negate(): Integer;
        // (undocumented)
        not(): Integer;
        // (undocumented)
        notEquals(other: Integer): boolean;
        // (undocumented)
        static ONE: Integer;
        // (undocumented)
        or(other: Integer): Integer;
        // (undocumented)
        shiftLeft(numBits: number): Integer;
        // (undocumented)
        shiftRight(numBits: number): Integer;
        // (undocumented)
        shorten(numBits: number): Integer;
        // (undocumented)
        subtract(other: Integer): Integer;
        // (undocumented)
        static toBuffer(value: Integer): Buffer;
        // (undocumented)
        toInt(): number;
        // (undocumented)
        toJSON(): string;
        // (undocumented)
        toNumber(): number;
        // (undocumented)
        toString(opt_radix?: number): string;
        // (undocumented)
        xor(other: Integer): Integer;
        // (undocumented)
        static ZERO: Integer;
    }

    const // (undocumented)
    unset: object;

    // (undocumented)
    export class LocalDate {
        constructor(year: number, month: number, day: number);
        // (undocumented)
        day: number;
        // (undocumented)
        equals(other: LocalDate): boolean;
        // (undocumented)
        static fromBuffer(buffer: Buffer): LocalDate;
        // (undocumented)
        static fromDate(date: Date): LocalDate;
        // (undocumented)
        static fromString(value: string): LocalDate;
        // (undocumented)
        inspect(): string;
        // (undocumented)
        month: number;
        // (undocumented)
        static now(): LocalDate;
        // (undocumented)
        toBuffer(): Buffer;
        // (undocumented)
        toJSON(): string;
        // (undocumented)
        toString(): string;
        // (undocumented)
        static utcNow(): LocalDate;
        // (undocumented)
        year: number;
    }

    // (undocumented)
    export class LocalTime {
        constructor(totalNanoseconds: Long);
        // (undocumented)
        compare(other: LocalTime): boolean;
        // (undocumented)
        equals(other: LocalTime): boolean;
        // (undocumented)
        static fromBuffer(value: Buffer): LocalTime;
        // (undocumented)
        static fromDate(date: Date, nanoseconds: number): LocalTime;
        // (undocumented)
        static fromMilliseconds(milliseconds: number, nanoseconds?: number): LocalTime;
        // (undocumented)
        static fromString(value: string): LocalTime;
        // (undocumented)
        getTotalNanoseconds(): Long;
        // (undocumented)
        hour: number;
        // (undocumented)
        inspect(): string;
        // (undocumented)
        minute: number;
        // (undocumented)
        nanosecond: number;
        // (undocumented)
        static now(nanoseconds?: number): LocalTime;
        // (undocumented)
        second: number;
        // (undocumented)
        toBuffer(): Buffer;
        // (undocumented)
        toJSON(): string;
        // (undocumented)
        toString(): string;
    }

    // (undocumented)
    export class Long extends _Long {

    }

    // (undocumented)
    export enum protocolVersion {
        // (undocumented)
        dseV1 = 0x41,
        // (undocumented)
        dseV2 = 0x42,
        // (undocumented)
        maxSupported = dseV2,
        // (undocumented)
        minSupported = v1,
        // (undocumented)
        v1 = 0x01,
        // (undocumented)
        v2 = 0x02,
        // (undocumented)
        v3 = 0x03,
        // (undocumented)
        v4 = 0x04,
        // (undocumented)
        v5 = 0x05,
        // (undocumented)
        v6 = 0x06
    }

    // (undocumented)
    export namespace protocolVersion {
        // (undocumented)
        export function isSupported(version: protocolVersion): boolean;
    }

    // (undocumented)
    export enum responseErrorCodes {
        // (undocumented)
        alreadyExists = 0x2400,
        // (undocumented)
        badCredentials = 0x0100,
        // (undocumented)
        clientWriteFailure = 0x8000,
        // (undocumented)
        configError = 0x2300,
        // (undocumented)
        functionFailure = 0x1400,
        // (undocumented)
        invalid = 0x2200,
        // (undocumented)
        isBootstrapping = 0x1002,
        // (undocumented)
        overloaded = 0x1001,
        // (undocumented)
        protocolError = 0x000A,
        // (undocumented)
        readFailure = 0x1300,
        // (undocumented)
        readTimeout = 0x1200,
        // (undocumented)
        serverError = 0x0000,
        // (undocumented)
        syntaxError = 0x2000,
        // (undocumented)
        truncateError = 0x1003,
        // (undocumented)
        unauthorized = 0x2100,
        // (undocumented)
        unavailableException = 0x1000,
        // (undocumented)
        unprepared = 0x2500,
        // (undocumented)
        writeFailure = 0x1500,
        // (undocumented)
        writeTimeout = 0x1100
    }

    // (undocumented)
    export interface ResultSet extends Iterable<Row>, AsyncIterable<Row> {
        // (undocumented)
        columns: Array<{ name: string, type: { code: dataTypes, info: any } }>;

        // (undocumented)
        first(): Row;

        // (undocumented)
        info: {
            queriedHost: string,
            triedHosts: { [key: string]: any; },
            speculativeExecutions: number,
            achievedConsistency: consistencies,
            traceId: Uuid,
            warnings: string[],
            customPayload: any
        };

        // (undocumented)
        nextPage: (() => void) | null;

        // (undocumented)
        pageState: string;

        // (undocumented)
        rowLength: number;

        // (undocumented)
        rows: Row[];

        // (undocumented)
        wasApplied(): boolean;
    }

    // (undocumented)
    export interface ResultStream extends stream.Readable {
        // (undocumented)
        add(chunk: Buffer): void;
        // (undocumented)
        buffer: Buffer;
        // (undocumented)
        paused: boolean;
    }

    // (undocumented)
    export interface Row {
        // (undocumented)
        [key: string]: any;

        // (undocumented)
        forEach(callback: (row: Row) => void): void;

        // (undocumented)
        get(columnName: string | number): any;

        // (undocumented)
        keys(): string[];

        // (undocumented)
        values(): any[];
    }

    // (undocumented)
    export class TimeUuid extends Uuid {
        // (undocumented)
        static fromDate(date: Date, ticks?: number, nodeId?: string | Buffer, clockId?: string | Buffer): TimeUuid;

        // (undocumented)
        static fromDate(
        date: Date,
        ticks: number,
        nodeId: string | Buffer,
        clockId: string | Buffer,
        callback: ValueCallback<TimeUuid>): void;

        // (undocumented)
        static fromString(value: string): TimeUuid;

        // (undocumented)
        getDate(): Date;

        // (undocumented)
        getDatePrecision(): { date: Date, ticks: number };

        // (undocumented)
        static max(date: Date, ticks: number): TimeUuid;

        // (undocumented)
        static min(date: Date, ticks: number): TimeUuid;

        // (undocumented)
        static now(): TimeUuid;

        // (undocumented)
        static now(nodeId: string | Buffer, clockId?: string | Buffer): TimeUuid;

        // (undocumented)
        static now(nodeId: string | Buffer, clockId: string | Buffer, callback: ValueCallback<TimeUuid>): void;

        // (undocumented)
        static now(callback: ValueCallback<TimeUuid>): void;
    }

    // (undocumented)
    export class Tuple {
        constructor(...args: any[]);
        // (undocumented)
        elements: any[];
        // (undocumented)
        static fromArray(elements: any[]): Tuple;
        // (undocumented)
        get(index: number): any;
        // (undocumented)
        length: number;
        // (undocumented)
        toJSON(): string;
        // (undocumented)
        toString(): string;
        // (undocumented)
        values(): any[];
    }

    // (undocumented)
    export class Uuid {
        constructor(buffer: Buffer);

        // (undocumented)
        equals(other: Uuid): boolean;

        // (undocumented)
        static fromString(value: string): Uuid;

        // (undocumented)
        getBuffer(): Buffer;

        // (undocumented)
        static random(callback: ValueCallback<Uuid>): void;

        // (undocumented)
        static random(): Uuid;

        // (undocumented)
        toJSON(): string;

        // (undocumented)
        toString(): string;
    }
}

// @public (undocumented)
export type ValueCallback<T> = (err: Error, val: T) => void;

// @public (undocumented)
export const version: number;

// (No @packageDocumentation comment for this package)

```
